import { google } from "@ai-sdk/google";
import { input, confirm } from "@inquirer/prompts";
import {
  coreMessageSchema,
  generateObject,
  generateText,
  Tool,
  type ToolCall,
  type ToolResult,
} from "ai";
import * as dotenv from "dotenv";
import { tool } from "ai";
import { z } from "zod";
import { marked } from "marked";
import { markedTerminal } from "marked-terminal";
import dedent from "dedent";

dotenv.config();

marked.use(
  // @ts-expect-error - Type compatibility issue between marked and marked-terminal
  markedTerminal({
    // Basic configuration for better rendering
    tab: 2, // Tab size in spaces
    showSectionPrefix: false, // Don't show section prefixes
    reflowText: true, // Reflow text for better formatting
    width: 80, // Width for reflowed text
  }),
);
// Use the schema to infer the message type
type TMessage = z.infer<typeof coreMessageSchema>;

type Conversation = TMessage[];

class CodeAgent {
  public conversation: Conversation = [];

  private get tools() {
    const codeGenerationTool = tool({
      description:
        "This is a code generation tool. Hereafter addressed as code_gen. This tool generates code based on user's query. Use it when the user asks for code. This will respond with code block.",
      parameters: z.object({
        query: z
          .string()
          .describe(
            "code you want the tool to generate. you can modify the user query to get better results.",
          ),
      }),
      execute: async ({ query }) => {
        const code = await generateObject({
          model: this.model,
          system:
            "You are a code generator. Generate code based on the user's query",
          prompt: query,
          schema: z.object({
            code: z.string().describe("The code generated by the tool"),
            language: z.string().describe("The language of the code"),
          }),
        });
        console.log("Code generated:", code);
        return code;
      },
    });

    return {
      codeGenerationTool,
    };
  }

  private async addUserMessage(message: string) {
    console.log("User message added");
    this.conversation.push({
      role: "user",
      content: message,
    });
  }

  private async addAssistantMessage(message: string) {
    console.log("Assistant message added");
    this.conversation.push({
      role: "assistant",
      content: message,
    });
  }

  private async addToolCallMessage(
    toolCall: ToolCall<"codeGenerationTool", { query: string }>,
  ): Promise<void> {
    console.log("Tool call added", toolCall);

    // Instead of trying to match the exact structure with TypeScript,
    // we'll create a message object and then parse it through the schema
    const messageObj = {
      role: "assistant",
      content: "",
      tool_calls: [
        {
          id: toolCall.toolCallId,
          type: "function",
          function: {
            name: toolCall.toolName,
            arguments: JSON.stringify(toolCall.args),
          },
        },
      ],
    };

    // Parse the message through the schema to ensure it's valid
    // This will throw if the message is invalid
    const message = coreMessageSchema.parse(messageObj);
    this.conversation.push(message);
  }

  private async addToolResultMessage(
    toolResult: ToolResult<string, Record<string, unknown>, unknown>,
  ): Promise<void> {
    console.log("Tool result added", toolResult);

    // Format the result content properly
    const resultContent =
      typeof toolResult.result === "string"
        ? toolResult.result
        : JSON.stringify(toolResult.result, null, 2);

    // Create a message object and parse it through the schema
    const messageObj = {
      role: "tool",
      tool_call_id: toolResult.toolCallId,
      name: toolResult.toolName,
      content: resultContent,
    };

    // Parse the message through the schema to ensure it's valid
    const message = coreMessageSchema.parse(messageObj);
    this.conversation.push(message);
  }

  private get model() {
    const model = google("gemini-1.5-flash");
    return model;
  }

  private async getUserMessage() {
    const userMessage = await input({
      message: "Enter your message",
    });
    return userMessage;
  }

  private async getAssistantResponse(): Promise<string> {
    const response = await generateText({
      model: this.model,
      messages: this.conversation,
      system: dedent`
      You are CoDoge, the coding agent.

      CoDoge supports the user in their coding journey.
      CoDoge may take the role of an expert, a teacher, or a mentor.
      CoDoge as access to tools that it can use to generate code.
    
      <tools>
        codeGenerationTool: use this tool to generate code. This tool only generates code and does not execute it. You might want to annotate the code with comments to explain what the code does.
      </tools>
      
      `,
      tools: this.tools,
    });

    // console.dir(response, { depth: 10 });

    if (response.toolCalls.length > 0) {
      for (const toolCall of response.toolCalls) {
        if (toolCall.toolName === "codeGenerationTool") {
          await this.addToolCallMessage(toolCall);

          for (const toolResult of response.toolResults) {
            if (toolResult.toolName === "codeGenerationTool") {
              await this.addToolResultMessage(toolResult);
              return await this.getAssistantResponse();
            }
          }
        }
      }
    }

    return response.text;
  }

  public async run() {
    while (true) {
      const userMessage = await this.getUserMessage();
      await this.addUserMessage(userMessage);
      const assistantMessage = await this.getAssistantResponse();
      await this.addAssistantMessage(assistantMessage);
      //   console.log("Conversation:", this.conversation);
      console.log("🐶 Codoge:\n", marked(assistantMessage));
    }
  }
}

if (require.main === module) {
  (async () => {
    console.clear();
    const codeAgent = new CodeAgent();
    console.log("Chat with Codoge the Code Agent (use 'ctrl-c' to quit)");
    const shouldRun = true;
    // await confirm({
    //   message: "Are you sure you want to run the code agent?",
    // });
    if (!shouldRun) {
      console.log("Code agent cancelled");
      process.exit(0);
    }

    await codeAgent.run();
  })().catch((error) => {
    console.error("Error:", error);
    process.exit(1);
  });
}
